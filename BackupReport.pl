#!c:/perl/bin/perl

# MIT License
#
# Copyright (c) 2025 Sigmund Straumland
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.



use strict;
use warnings;
use Time::Local;
use Win32;



our $APP_AUTH = 'Sigmund Straumland';
our $APP_USER = Win32::LoginName() || "Unknown";
our $APP_USER_MACHINE = Win32::NodeName() || "Unknown";
our $APP_WEB = 'https://www.straumland.com';
our $APP_DATETIME = getDateTime();

our(@TASKS, @MODULES, %SYSPAR, @ROUTINES, @VARIABLES);



Find_All_Tasks();
Find_All_Modules();
Find_All_Syspar();
Find_All_ProcFuncTrap();
Find_All_Variables();



# Generate MD report to be synced to repo
Generate_Report();



print "\n".'DONE!'."\n";
sleep(3);



exit;



#



sub Generate_Report {
	my $report;
	
	my $variables = '## Variables' . "\n\n";
	$variables .= '### Prefixes check' . "\n\n";
	$variables .= ReportGen_VariablePrefixes() . "\n\n";
	$variables .= '### Task shared' . "\n\n";
	$variables .= ReportGen_TaskSharedVariables() . "\n\n";	
	$variables .= '---' . "\n\n";
	
	my $routines = '## Routines' . "\n\n";
	$routines .= '### Size' . "\n\n";
	$routines .= ReportGen_RoutineSize() . "\n\n";
	$routines .= '### Comments' . "\n\n";
	$routines .= ReportGen_RoutineComments() . "\n\n";
	$routines .= '---' . "\n\n";

	my $io = '## IO' . "\n\n";
	$io .= '### Prefixes' . "\n\n";
	$io .= ReportGen_IoPrefixes() . "\n\n";
	$io .= '### Labels and category' . "\n\n";
	$io .= ReportGen_LabelCategory() . "\n\n";
	$io .= '### Access Level' . "\n\n";
	$io .= ReportGen_AccessLevel() . "\n\n";
	$io .= '---' . "\n\n";

	my $instructions = '## Instructions' . "\n\n";
	$instructions .= '### Forbidden' . "\n\n";
	$instructions .= ReportGen_InstructionsForbidden() . "\n\n";
	$instructions .= '### Ok but consider alternative' . "\n\n";
	$instructions .= ReportGen_InstructionsRatherNot() . "\n\n";
	$instructions .= '---' . "\n\n";

	my $summary = '## Summary' . "\n\n";
	$summary .= 'Tasks: ' . ($#TASKS + 1) . '  ' . "\n";
	$summary .= 'Modules: ' . ($#MODULES + 1) . '  ' . "\n";
	$summary .= 'SystemParameters: ' . (scalar keys %SYSPAR) . '  ' . "\n";
	$summary .= 'Routines: ' . ($#ROUTINES + 1) . '  ' . "\n";
	$summary .= 'Variables: ' . ($#VARIABLES + 1) . '  ' . "\n\n";
	$summary .= '---'."\n\n";
	
	open(my $MD, '>BackupReport.md');
	print $MD '# BackupReport report' . "\n\n";
	print $MD $summary;
	print $MD '[Summary](#summary)  ' . "\n";
	print $MD '[Routine Size](#size)  ' . "\n";
	print $MD '[Routine Comments](#comments)  ' . "\n";
	print $MD '[IO Prefixes](#io)  ' . "\n";
	print $MD '[IO Labels and category](#io)  ' . "\n";
	print $MD '[IO Access Level](#io)  ' . "\n";
	print $MD '[ProgramData prefixes](#prefixes-check)  ' . "\n";
	print $MD '[Shared ProgramData](#task-shared)  ' . "\n";
	print $MD '[Instruction-checks](#instructions)  ' . "\n\n";
	print $MD 'Generated by: ' . $APP_USER . '/' . $APP_USER_MACHINE . ' on ' . $APP_DATETIME . '.  ' . "\n";
	print $MD '[' . $APP_WEB . '](' . $APP_WEB . ')  ' . "\n\n";
	print $MD '---' . "\n\n";
	print $MD $routines;
	print $MD $variables;
	print $MD $io;
	print $MD $instructions;
	close($MD);
}



sub ReportGen_AccessLevel {
	
	my $res;
	
	$res .= 'EIO.cfg not found. No check performed.' . "\n\n" if (!($SYSPAR{eio}));

	my(@signals) = ReadSyspar($SYSPAR{eio}, 'EIO_SIGNAL');
	my(@access) = ReadSyspar($SYSPAR{eio}, 'EIO_ACCESS');

	foreach my $line (@signals) {
		my $io_name = getSysparValue($line, 'name');
		my $io_access = getSysparValue($line, 'access');
		
		my $access_rapid = getSysparValue(getSysparLine($io_access, 'x', @access), 'rapid');
		my $access_localauto = getSysparValue(getSysparLine($io_access, 'x', @access), 'localauto');
		my $access_localmanual = getSysparValue(getSysparLine($io_access, 'x', @access), 'localmanual');
		my $access_remoteauto = getSysparValue(getSysparLine($io_access, 'x', @access), 'remoteauto');
		my $access_remotemanual = getSysparValue(getSysparLine($io_access, 'x', @access), 'remotemanual');

		$res .= '``WARNING IO access in auto or from remote (' . $io_access . ') ' . $io_name . ' Line ' . getSysparValue($line, 'fileline') . '``' . "\n\n" if (($access_localauto) || ($access_remoteauto) || ($access_remotemanual) || (lc($io_access) eq 'all'));
	}
	
	if ($res) {
		$res = 'These IO can be toggled in auto or from remote, please consider limiting access due to safety.' . "\n\n" . $res;
		$res = 'No score will be given for this section. Specifications from customer or process may affect strategy when deciding on access configuration. However here you can get a quick overview of the current configuration.' . "\n\n" . $res;
	} else {
		$res = 'No errors found! Good Job!' . "\n\n";
	}

	return $res;
}



sub ReportGen_LabelCategory {
	
	my $res;
	
	$res .= 'EIO.cfg not found. No check performed.' . "\n\n" if (!($SYSPAR{eio}));

	my(@signals) = ReadSyspar($SYSPAR{eio}, 'EIO_SIGNAL');

	foreach my $line (@signals) {
		my $io_name = getSysparValue($line, 'name');
		my $io_label = getSysparValue($line, 'label');
		my $io_category = getSysparValue($line, 'category');
		
		$res .= '``ERROR Missing label for ' . $io_name . ' Line ' . getSysparValue($line, 'fileline') . '``' . "\n\n" if ($io_label eq '');
		$res .= '``ERROR Missing category for ' . $io_name . ' Line ' . getSysparValue($line, 'fileline') . '``' . "\n\n"if ($io_category eq '');
	}
	
	$res .= $res ? 'Requirements are to follow ABB documentation, Reference manual Naming convention 3HNA013447-001 en Rev.03.' . "\n" : 'No errors found! Good Job!' . "\n\n";
	
	return $res;
}



sub ReportGen_IoPrefixes {
	
	my $res;
	
	$res .= 'EIO.cfg not found. No check performed.' . "\n\n" if (!($SYSPAR{eio}));
	
	my(@signals) = ReadSyspar($SYSPAR{eio},'EIO_SIGNAL');
	
	# System IO are read from both EIO.cfg and SYS.cfg due to older systems keeping these
	# values in EIO.cfg, and newer omnicore systems keep them in SYS.cfg.
	my(@systemin_eio) = ReadSyspar($SYSPAR{eio},'SYSSIG_IN');
	my(@systemout_eio) = ReadSyspar($SYSPAR{eio},'SYSSIG_OUT');
	my(@systemin_sys) = ReadSyspar($SYSPAR{sys},'SYSSIG_IN');
	my(@systemout_sys) = ReadSyspar($SYSPAR{sys},'SYSSIG_OUT');

	my(@cross) = ReadSyspar($SYSPAR{eio},'EIO_CROSS');

	foreach my $line (@signals) {
		my $io_name = getSysparValue($line, 'name');
		my $io_prefix = lc(getSysparValue($line, 'signaltype'));

		if (getSysparLine('signal', $io_name, (@systemin_eio, @systemout_eio)) ne '') {
			# This is the old IRC5 format
			$io_prefix = 's' . $io_prefix;
		} elsif (getSysparLine('name', $io_name, (@systemin_sys, @systemout_sys)) ne '') {
			# This is the newer omnicore format
			$io_prefix = 's' . $io_prefix;
		} elsif (getSysparLine('res', $io_name, @cross) ne '') {
			$io_prefix = 'x' . $io_prefix;
		}

		if ($io_name !~ /^$io_prefix/) {
			$res .= '``ERROR Expected prefix ' . $io_prefix . ' for ';
			if ($io_prefix =~ /^x/) {
				$res .= 'cross-connected ';
			} elsif ($io_prefix =~ /^s/) {
				$res .= 'system-io ';
			}
			$res .= $io_name . ' Line ' . getSysparValue($line, 'fileline') . '``' . "\n\n";
		}
	}
	
	$res .= $res ? 'Requirements are to follow ABB documentation, Reference manual Naming convention 3HNA013447-001 en Rev.03.' . "\n" : 'No errors found! Good Job!' . "\n\n";
	
	return $res;
}



sub getSysparValue {
	my($line, $arg) = @_;

	my(@pairs) = split(/;/, $line);
	foreach my $pair (@pairs) {
		my($name, $value) = split(/=/, $pair);
		return $value if (lc($name) eq lc($arg));
	}
}



sub getSysparLine {
	my($argname, $argval, @arr) = @_;
	
	foreach my $line (@arr) {
		my(@pairs) = split(/;/, $line);
		foreach my $pair (@pairs) {
			my($name, $value) = split(/=/, $pair);
			return $line if ((lc($name) eq lc($argname)) && (lc($value) eq lc($argval)));
		}
	}
	return '';
}



sub ReadSyspar {
	my($filepath, $section) = @_;

	my(@res);

	my $fileline = 0;
	my $section_signal = 0;
	my $multiline = '';

	open(my $FILE,'<'.$filepath);
	while (my $line = <$FILE>) {
		# Trim junk
		$line =~ s/^[\s\t]+//;
		$line =~ s/[\s\t]+$//;
		$line =~ s/[\s\t]+/ /g;
		
		# Add fileline counter
		$fileline++;
		
		# Register signal section of EIO.cfg. $section can be for example 'EIO_SIGNAL'
		if ($line =~ /^$section:/) {
			$section_signal = 1;
			next;
		}
		
		# Next if we are in wrong section
		next if ($section_signal == 0);

		# No more signals
		last if (($section_signal) && ($line =~ /^#/));		
		
		while ($line =~ /\\$/) {
			# Multiline

			# Remove backslash
			chop($line);

			# Append the next line
			$line .= <$FILE>;

			# Trim junk
			$line =~ s/^[\s\t]+//;
			$line =~ s/[\s\t]+$//;
			$line =~ s/[\s\t]+/ /g;

			# Add fileline counter
			$fileline++;
		}
		
		# Empty line, skip to next
		next unless ($line);

		# Parse line, try to change data from:
		#   -Name "Value" -Name "Value"
		# to:
		#   Name=Value;Name=Value;
		# NOTE! If labels are not registered, check the contents of the label. The regex below
		#   may need to be expanded to include "off-spec" characters.
		$line =~ s/-([\w\d_]+)\s+"([\w\d_\-,\s\.]+)"\s?/$1=$2;/gi;
		# Try to change data from:
		#   -Name -Name
		# to:
		#   Name=x;Name=x;
		$line =~ s/-([\w\d_]+)\s+/$1=x;/gi;
				
		# Push data into array. $line should end with a semicolon here
		push(@res, $line . 'fileline=' . $fileline);
	}
	close($FILE);
	
	# Array should look like this
	#   ("Name=Val;Name=Val;", "Name=Val;Name=Val;Name=Val", ...)
	return @res;
}



sub ReportGen_InstructionsForbidden {	
	
	my $res;
	
	foreach my $module (@MODULES) {
		my($modname, $modpath, $modtask) = split(/;/, $module);
	
		my $fileline = 0;
		
		open(my $MOD, '<' . $modpath);
		while (my $line = <$MOD>) {
			$fileline++;
			
			$res .= '``ERROR Illegal instruction GOTO.`` ' . $modtask . '/' . $modname . ' Line ' . $fileline . "\n\n" if ($line =~ /goto[\s\t]+[\w\d_]+[\s\t]*;/i);
		}
		close($MOD);			
	}
	
	$res = $res ? 'These are a sign of lazy code and introduces technical debt. Rewrite to maintainable code, please.' . "\n\n" . $res : 'None found! Good Job!' . "\n\n";
	
	return $res;
}



sub ReportGen_InstructionsRatherNot {	
	
	my $res;
	
	foreach my $module (@MODULES) {
		my($modname, $modpath, $modtask) = split(/;/, $module);
	
		my $fileline = 0;
		
		open(my $MOD, '<' . $modpath);
		while (my $line = <$MOD>) {
			$fileline++;
			
			if ($line =~ /^[\s\t]*callbyvar\W/i) {
				$res .= '``WARNING consider non-runtime-dependant CallByVar. ' . $modtask . '/' . $modname . ' Line ' . $fileline . '``' . "\n\n";
			} elsif ($line =~ /^[\s\t]*\%[^\%]/i) {
				$res .= '``WARNING consider non-runtime-dependant %<string>%. ' . $modtask . '/' . $modname . ' Line ' . $fileline . '``' . "\n\n";
			}
		}
		close($MOD);			
	}

	$res = $res ? 'None of these will affect score. However they increase complexity, so please use sparingly.' . "\n\n" . $res : 'None found! Good Job!' . "\n\n";
	
	return $res;
}



sub ReportGen_RoutineComments {
	
	my $commentcountlimitpercent = 33;
	
	# Declare resultvariable
	my $res;
	
	# Loop through each routine
	my $routineline;
	foreach my $routine (@ROUTINES) {
		my($routinename, $routinemodule, $routinetask) = split(/;/, $routine);
		
		my $routinepart = 0;
		my $linecount = 0;
		my $commentcount = 0;
		my $fileline = 0;

		# Open file for reading
		open(my $MOD, '<' . getRoutinePath($routinemodule, $routinetask));
		while (my $line = <$MOD>) {
			$fileline++;
			
			# Read until we find the right routine
			if ($line =~ /^[\s\t]*(local\s+)?(proc|func\s+[\w_]+|trap)\s+([\w\d_]+)/i) {
				if ($3 eq $routinename) {
					# Routine start
					$routinepart = 1;
					$routineline = $fileline;
				}
			} elsif (($routinepart == 1) && ($line =~ /^[\s\t]*(end(proc|func|trap)|error|return|undo)/i)) {
				# Routine end, exit loop
				last;
			}

			# Count instruction lines
			$linecount++ if (($routinepart == 1) && ($line =~ /;[\s\t]*$/));
			
			# Comments which looks like instructions will be skipped
			if ($line =~ /^[\s\t]*![\s\t]*(if|for|while|test|case|endif|endfor|endtest|default)\W/i) {
				# Comments which looks like if or loops are not counted
				next;
			} elsif ($line =~ /;[\s\t]*$/i) {
				# Anything ending with ; looks suspiciously like an instruction
				next;
			}
			
			# Comments with at least 10 length are counted
			$commentcount++ if (($routinepart == 1) && ($line =~ /^[\s\t]*!.{10,}?$/));
		}
		close($MOD);
		
		$res .= '``ERROR: Min comment count ratio not met (' . $commentcountlimitpercent . '%) ' . $routinetask . '/' . $routinemodule . '/' . $routinename . ' Line ' . $routineline . ' Linecount: ' . $linecount . ' Commentcount: ' . $commentcount . '``' . "\n\n" if (($linecount > 6) && ($commentcount < ($linecount * ($commentcountlimitpercent / 100))));
	}

	$res .= "\n" . 'Instructions are counted, not FOR/IF/WHILE etc. Errorlimit is set to ' . $commentcountlimitpercent . '%.' . "\n";
		
	return $res;
}



sub ReportGen_RoutineSize {
	
	my $linecountlimiterror = 50;
	my $linecountlimitwarning = 30;
	
	# Declare resultvariable
	my $res;	

	foreach my $routine (@ROUTINES) {
		my($routinename, $routinemodule, $routinetask) = split(/;/, $routine);
		
		my $routinepart = 0;
		my $linecount = 0;
		my $fileline = 0;
		my $routineline = '';
		
		open(my $MOD, '<' . getRoutinePath($routinemodule, $routinetask));
		while (my $line = <$MOD>) {
			$fileline++;
			
			if ($line =~ /^[\s\t]*(local\s+)?(proc|func\s+[\w_]+|trap)\s+([\w\d_]+)/i) {
				if ($3 eq $routinename) {
					# Routine start
					$routinepart = 1;
					$routineline = $fileline;
				}
			} elsif (($routinepart == 1) && ($line =~ /^[\s\t]*(end(proc|func|trap)|error|return|undo)/i)) {
				# Routine end
				last;
			}

			$linecount++ if (($routinepart == 1) && ($line =~ /;[\s\t]*(!|$)/));
		}
		close($MOD);
		
		if ($linecount > $linecountlimiterror) {
			$res .= '``ERROR: Routine max line count (' . $linecountlimiterror . ') exceeded. ' . $routinetask . '/' . $routinemodule . '/' . $routinename . ' Line ' . $routineline . ' Linecount: ' . $linecount . '``' . "\n\n";
		} elsif ($linecount > $linecountlimitwarning) {
			$res .= '``WARNING: Routine recommended max line count (' . $linecountlimitwarning . ') exceeded. ' . $routinetask . '/' . $routinemodule . '/' . $routinename . ' Line ' . $routineline . ' Linecount: ' . $linecount . '``' . "\n\n";
		}
		
	}

	$res .= "\n" . 'Instructions are counted, not comments or FOR/IF/WHILE etc. Errorlimit is set to ' . $linecountlimiterror . ', warninglimit is set to ' . $linecountlimitwarning . '.  ' . "\n";
	
	return $res;
}



sub ReportGen_VariablePrefixes {
	
	# Declare resultvariable
	my $res;
	
	# Reference manual Naming convention 3HNA013447-001 en Rev.03
	my(%prefix_def) = (
		'bool'=>'b',
		'clock'=>'ck',
		'confdata'=>'cf',
		'dionum'=>'i',
		'dir'=>'d',
		'eventdata'=>'ed',
		'errnum'=>'er;ERR_',
		'extjoint'=>'exj',
		'intnum'=>'ir',
		'iodev'=>'de',
		'jointtarget'=>'jpos;j',
		'loaddata'=>'lo',
		'loadsession'=>'loadid',
		'mecunit'=>'me',
		'motsetdata'=>'mo',
		'num'=>'n;reg',
		'orient'=>'or',
		'pos'=>'ps',
		'pose'=>'pe',
		'progdisp'=>'pd',
		'robtarget'=>'p',
		'shapedata'=>'shd',
		'speeddata'=>'v',
		'string'=>'st',
		'tooldata'=>'t',
		'triggdata'=>'tr',
		'wobjdata'=>'wobj',
		'wzstationary'=>'wzs',
		'wztemporary'=>'wzt',
		'zonedata'=>'z');
	
	foreach my $var (@VARIABLES) {
		my($localtype, $local, $vartype, $type, $name, $modname, $fileline, $taskname, $init_value) = split(/;/, $var);
		
		if (defined($prefix_def{$type})) {
			my(@valid_prefixes) = split(/;/, $prefix_def{$type});
			
			my $valid = 0;
			my $found_prefix = 'NA';
			foreach (@valid_prefixes) {
				if ($name =~ /^($_)\u\w/) {
					$found_prefix = $1;
					$valid = 1;
					last;
				}
			}
			
			if (!($valid))  {
				$res .= '``ERROR: Invalid programdata prefix (' . $type . '/' . $prefix_def{$type} . '). ' . $taskname . '/' . $modname . ' Line ' . $fileline . ' ' . $type . ' ' . $name . '``' . "\n\n";
			} elsif ($name !~ /^$found_prefix\u\w\w{2}/) {
				$res .= '``ERROR: Missing programdata name. ' . $taskname . '/' . $modname . ' Line ' . $fileline . ' ' . $type . ' ' . $name . '``' . "\n\n";
			}
		} else {
			# Record type?
		}
	}
	
	$res = 'No errors found! Good job!'."\n\n" unless ($res);
	
	$res .= 'Requirements are to follow ABB documentation, Reference manual Naming convention 3HNA013447-001 en Rev.03.' . "\n";

	# Return results
	return $res;
}



sub ReportGen_TaskSharedVariables {
	
	return 'Not applicable when only one task.'."\n\n" if ($#TASKS <= 0);

	my(%tasksharedvariables);

	# First iteration, find variables declared as system global
	foreach my $var (@VARIABLES) {
		my($localtype, $local, $vartype, $type, $name, $modname, $fileline, $taskname, $init_value) = split(/;/, $var);

		if ((lc($localtype) eq 'module') && ($local eq '') && (lc($vartype) eq 'pers')) {

			foreach my $var_ (@VARIABLES) {
				my($localtype_, $local_, $vartype_, $type_, $name_, $modname_, $fileline_, $taskname_, $init_value_) = split(/;/, $var_);

				if ((lc($localtype_) eq 'module') && ($local_ eq '') && (lc($vartype_) eq 'pers')) {
				
					if (($name eq $name_) && ($taskname ne $taskname_)) {
						$tasksharedvariables{$name} = $vartype . ' ' . $type . ' ' . $name;
						last;
					}
				}
			}
		}
	}
	
	# Second iteration, find each shared
	my(%taskcount);
	# Declare resultvariable
	my $res_varlist;
	foreach my $sharedname (keys %tasksharedvariables) {
		
		$res_varlist .= '```' . "\n" . $tasksharedvariables{$sharedname} . "\n";
		my $initvalue_found = 0;

		foreach my $var (@VARIABLES) {
			my($localtype, $local, $vartype, $type, $name, $modname, $fileline, $taskname, $init_value) = split(/;/, $var);

			if (($tasksharedvariables{$name}) && ($sharedname eq $name)) {	
				$res_varlist .= '    ' . $taskname . '/' . $modname;
				if ($init_value) {
					$res_varlist .= ' InitValue';
					$res_varlist .= ' ERROR Multiple Initvalue declarations.' if ($initvalue_found);
					$initvalue_found = 1;
				}
				$res_varlist .= ' Line ' . $fileline . '  ' . "\n";
				$taskcount{$taskname}++;
			}
		}

		$res_varlist .= '```' . "\n\n";
	}
	$res_varlist .= $res_varlist ? "\n" : 'No task-shared programdata found.' . "\n\n";

	my(@taskcountkeys) = sort { $taskcount{$b} <=> $taskcount{$a} } keys %taskcount;
	my $res_tasklist;
	foreach my $task_i (0..$#taskcountkeys) {
		$res_tasklist .= '``' . $taskcountkeys[$task_i] . '``: ' . $taskcount{$taskcountkeys[$task_i]};
		$res_tasklist .= ' <-- Evaluated for score.' if ($task_i == 1);
		$res_tasklist .= '  ' . "\n";
	}
	$res_tasklist .= $res_tasklist ? "\n" : 'No task-shared programdata found.' . "\n\n";

	# Return results
	return '#### Tasklist and number of shared variables' . "\n\n" . $res_tasklist . '#### Variablelist and where they are shared' . "\n\n" . $res_varlist;
}



# getRoutinePath subroutine retrieves the path associated with a given module name.
# Parameters:
#   $modulename  - Module name for which the path is to be retrieved
# Returns:
#   Path associated with the module name or an error message if not found
sub getRoutinePath {
    my ($modulename, $moduletask) = @_;

    # Loop through each module in the @MODULES array
    foreach my $module (@MODULES) {
        # Split the module information into its components
        my($modname, $modpath, $taskname) = split(/;/, $module);

        # Check if the module name matches the provided $modulename
        # Return the path associated with the module name
        return $modpath if (($modname eq $modulename) && ($taskname eq $moduletask));
    }

    # If the module name is not found, return an error message
    return 'ERROR: Module name not found';
}



sub Find_All_Tasks {
	
	# We will open 'ProjectFilesRobot' folder and look for any folders named '^TASK' or '^RAPID'
	# If we find any '^TASK' folder we will use 'ProjectFilesRobot' as task folder.
	# Otherwise we try the same for '^RAPID' folder. If none found we will assume only TASK0 present in 'ProjectFilesRobot'
	push(@TASKS, ListTaskFolders('RAPID'));
	
	print 'Found Tasks:'."\n";
	foreach (@TASKS) {
		print $_."\n";
	}
	print "\n";
	# Done
}



sub FolderInFolder {
	my($re_name, $foldername) = @_;
	
	# Declare resultvariable and init false value
	my $res = 0;
	
	# open folder and loop through files
	opendir(my $DIR, $foldername);
	foreach my $de (readdir($DIR)) {
		if ((-d $foldername . '/' . $de) && ($de =~ /$re_name/)) {
			# Found what we were looking for
			# Change resultvariable and exit loop
			$res = 1;
			last;
		}
	}
	closedir($DIR);
	
	# Return results
	return $res;
}



sub ListTaskFolders {
	my($foldername) = @_;
	
	# Declare resultvariable and init false value
	my(@res) = ();
	
	# open folder and loop through files
	opendir(my $DIR, $foldername) or die('Cant open RAPID folder. Are you sure you put the script inside the backupfolder?');
	foreach my $de (readdir($DIR)) {
		# Add to results and continue
		push(@res, $1 . ';' . $foldername . '/' . $de) if ((-d $foldername . '/' . $de) && ($de =~ /(^TASK\d+)/));
	}
	closedir($DIR);
	
	die('No task folders found. Early exit...') if ($#res < 0);
	
	# Return results
	return @res;
}



sub Find_All_Modules {
	# Loop through each task, collect path info for each mod/sys file we find.
	foreach my $task (@TASKS) {
		my($taskname, $taskpath) = split(/;/, $task);
		push(@MODULES, ModuleSearch($taskpath, $taskname));
	}
	
	print 'Found Modules:' . "\n";
	foreach (@MODULES) {
		print $_ . "\n";
	}
	print "\n";
	# Done
}



sub ModuleSearch {
	my($foldername, $taskname) = @_;
	
	# Declare resultvariable and init false value
	my(@res) = ();
	
	# Open given folder, add any *.mod or *.sys files we find.
	# If we find any folders, use recursion by calling this routine again with new folder as target.
	opendir(my $DIR, $foldername);	
	foreach my $de (readdir($DIR)) {
		if (($de eq '.') || ($de eq '..')) {
			next;
		} elsif (-d $foldername . '/' . $de) {
			push(@res, ModuleSearch($foldername . '/' . $de, $taskname));
		} elsif ($de =~ /\.(mod|sys|modx|sysx)$/i) {
			push(@res, $de . ';' . $foldername . '/' . $de . ';' . $taskname);
		}
	}
	closedir($DIR);
	
	# Return results
	return @res;
}



sub Find_All_Syspar {
	SysparSearch('SYSPAR');

	print 'Found SysPar:' . "\n";
	my(@syspar_keys) = sort keys %SYSPAR;
	foreach (@syspar_keys) {
		print $SYSPAR{$_} . "\n";
	}
	print "\n";
	# Done
}



sub SysparSearch {
	my($foldername) = @_;
	
	# Open given folder, add EIO.CFG, early exit if found. 
	# If we find any folders, use recursion by calling this routine again with new folder as target.
	# Search function used for possible other syspar files added in the future.
	opendir(my $DIR, $foldername);
	foreach my $de (readdir($DIR)) {
		if (($de eq '.') || ($de eq '..')) {
			next;
		} elsif (-d $foldername . '/' . $de) {
			SysparSearch($foldername . '/' . $de);
		} elsif (lc($de) eq 'eio.cfg') {
			$SYSPAR{eio} = $foldername . '/' . $de;
		} elsif (lc($de) eq 'sys.cfg') {
			$SYSPAR{sys} = $foldername . '/' . $de;
		}
	}
	closedir($DIR);
}



sub Find_All_ProcFuncTrap {
	
	foreach my $mod (@MODULES) {
		my($modulename, $modulepath, $taskname) = split(/;/, $mod);		
		push(@ROUTINES, ProcFuncTrapSearch($modulepath, $modulename, $taskname));
	}	
	
	print 'Found ProcFuncTrap:' . "\n";
	foreach (@ROUTINES) {
		print $_ . "\n";
	}
	print "\n";
	# Done
}



sub ProcFuncTrapSearch {
	my($modpath, $modulename, $taskname) = @_;

	# Declare resultvariable and init false value
	my(@res) = ();
	
	open(my $FILE, '<' . $modpath);
	while (my $line = <$FILE>) {
		if ($line =~ /^[\s\t]*(local\s+)?(proc|func\s+[\w_]+|trap)\s+([\w\d_]+)/i) {
			# Routine start
			push(@res, $3 . ';' . $modulename . ';' . $taskname);
		} elsif ($line =~ /^[\s\t]*end(proc|func|trap)/i) {
			# Routine end
		}
	}
	close($FILE);	
	
	# Return results
	return @res;
}



sub Find_All_Variables {
	
	foreach my $mod (@MODULES) {
		my($modulename, $modulepath, $taskname) = split(/;/, $mod);		
		push(@VARIABLES, VariablesSearch($modulepath, $modulename, $taskname));
	}	
	
	print 'Found Variables:' . "\n";
	foreach (@VARIABLES) {
		print $_ . "\n";
	}
	print "\n";
	# Done
}



# VariablesSearch subroutine searches for variable declarations in a given file.
# Parameters:
#   $modpath     - Path to the file to be searched
#   $modulename  - Module name associated with the file
#   $taskname    - Task name associated with the file
# Returns:
#   An array containing information about variables found in the format:
#   [variable_type;variable_name;module_name;line_number;task_name, ...]
sub VariablesSearch {
    my ($modpath, $modulename, $taskname) = @_;

    # Declare result variable and initialize with an empty array
    my (@res) = ();

	my $routinedeclaration = 'module';
    my $fileline = 0;

    # Open the file for reading
    open(my $FILE, '<' . $modpath);

    # Loop through each line in the file
    while (my $line = <$FILE>) {
        $fileline++;
		
		# If we reach routinedeclaration all remaining variable declarations are routine-local
		$routinedeclaration = 'routine' if ($line =~ /^[\s\t]*(local\s+)?(proc|func|trap)\s/i);

        # Check if the line contains a variable declaration (local? + pers, var, or const)
        if ($line =~ /^[\s\t]*((local)\s+)?(pers|var|const)\s+([\w\d_]+)\s+([\w\d_]+)\s*(:=)?/i) {
			my $local = defined($2) ? $2 : '';
			my $init_value = defined($6) ? 1 : 0;
            # Extracted information is pushed to the result array
			push(@res, $routinedeclaration . ';' . $local . ';' . $3 . ';' . $4 . ';' . $5 . ';' . $modulename . ';' . $fileline . ';' . $taskname . ';' . $init_value);
        }
    }

    # Close the file
    close($FILE);

    # Return the array containing variable information
    return @res;
}



sub getDateTime {
	my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);
	return sprintf("%04d-%02d-%02d %02d:%02d:%02d", ($year + 1900), ($mon + 1), $mday, $hour, $min, $sec);
}